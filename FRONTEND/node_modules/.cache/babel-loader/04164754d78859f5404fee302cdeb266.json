{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nvar w = \"production\" !== process.env.NODE_ENV ? function (a) {\n  return Object.freeze(a);\n} : function (a) {\n  return a;\n};\n\nfunction x(a, f) {\n  if (!a) {\n    \"undefined\" !== typeof console && console.warn(f);\n\n    try {\n      throw Error(f);\n    } catch (h) {}\n  }\n}\n\nfunction y(a) {\n  a.preventDefault();\n  a.returnValue = \"\";\n}\n\nfunction z() {\n  var a = [];\n  return {\n    get length() {\n      return a.length;\n    },\n\n    push: function (f) {\n      a.push(f);\n      return function () {\n        a = a.filter(function (a) {\n          return a !== f;\n        });\n      };\n    },\n    call: function (f) {\n      a.forEach(function (a) {\n        return a && a(f);\n      });\n    }\n  };\n}\n\nfunction A() {\n  return Math.random().toString(36).substr(2, 8);\n}\n\nfunction C(a) {\n  var f = a.pathname,\n      h = a.search;\n  a = a.hash;\n  return (void 0 === f ? \"/\" : f) + (void 0 === h ? \"\" : h) + (void 0 === a ? \"\" : a);\n}\n\nfunction D(a) {\n  var f = {};\n\n  if (a) {\n    var h = a.indexOf(\"#\");\n    0 <= h && (f.hash = a.substr(h), a = a.substr(0, h));\n    h = a.indexOf(\"?\");\n    0 <= h && (f.search = a.substr(h), a = a.substr(0, h));\n    a && (f.pathname = a);\n  }\n\n  return f;\n}\n\nvar createBrowserHistory = function (a) {\n  function f() {\n    var a = k.location,\n        e = g.state || {};\n    return [e.idx, w({\n      pathname: a.pathname,\n      search: a.search,\n      hash: a.hash,\n      state: e.usr || null,\n      key: e.key || \"default\"\n    })];\n  }\n\n  function h(a) {\n    return \"string\" === typeof a ? a : C(a);\n  }\n\n  function r(a, e) {\n    void 0 === e && (e = null);\n    return w(_extends({}, m, {}, \"string\" === typeof a ? D(a) : a, {\n      state: e,\n      key: A()\n    }));\n  }\n\n  function u(a) {\n    n = a;\n    a = f();\n    p = a[0];\n    m = a[1];\n    c.call({\n      action: n,\n      location: m\n    });\n  }\n\n  function v(a, e) {\n    function c() {\n      v(a, e);\n    }\n\n    var B = r(a, e);\n\n    if (!b.length || (b.call({\n      action: \"PUSH\",\n      location: B,\n      retry: c\n    }), !1)) {\n      var d = [{\n        usr: B.state,\n        key: B.key,\n        idx: p + 1\n      }, h(B)];\n      B = d[0];\n      d = d[1];\n\n      try {\n        g.pushState(B, null, d);\n      } catch (E) {\n        k.location.assign(d);\n      }\n\n      u(\"PUSH\");\n    }\n  }\n\n  function t(a, e) {\n    function c() {\n      t(a, e);\n    }\n\n    var d = r(a, e);\n    b.length && (b.call({\n      action: \"REPLACE\",\n      location: d,\n      retry: c\n    }), 1) || (d = [{\n      usr: d.state,\n      key: d.key,\n      idx: p\n    }, h(d)], g.replaceState(d[0], null, d[1]), u(\"REPLACE\"));\n  }\n\n  function l(a) {\n    g.go(a);\n  }\n\n  a = (void 0 === a ? {} : a).window;\n  var k = void 0 === a ? document.defaultView : a,\n      g = k.history,\n      q = null;\n  k.addEventListener(\"popstate\", function () {\n    if (q) b.call(q), q = null;else {\n      var a = f(),\n          e = a[0];\n      a = a[1];\n      if (b.length) {\n        if (null != e) {\n          var c = p - e;\n          c && (q = {\n            action: \"POP\",\n            location: a,\n            retry: function () {\n              l(-1 * c);\n            }\n          }, l(c));\n        } else \"production\" !== process.env.NODE_ENV ? x(!1, \"You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.\") : void 0;\n      } else u(\"POP\");\n    }\n  });\n  var n = \"POP\";\n  a = f();\n  var p = a[0],\n      m = a[1],\n      b = z(),\n      c = z();\n  null == p && (p = 0, g.replaceState(_extends({}, g.state, {\n    idx: p\n  }), null));\n  return {\n    get action() {\n      return n;\n    },\n\n    get location() {\n      return m;\n    },\n\n    createHref: h,\n    push: v,\n    replace: t,\n    go: l,\n    back: function () {\n      l(-1);\n    },\n    forward: function () {\n      l(1);\n    },\n    listen: function (a) {\n      return c.push(a);\n    },\n    block: function (a) {\n      var e = b.push(a);\n      1 === b.length && k.addEventListener(\"beforeunload\", y);\n      return function () {\n        e();\n        b.length || k.removeEventListener(\"beforeunload\", y);\n      };\n    }\n  };\n};\n\nvar createHashHistory = function (a) {\n  function f() {\n    var a = D(g.location.hash.substr(1)),\n        b = a.pathname,\n        c = a.search;\n    a = a.hash;\n    var d = q.state || {};\n    return [d.idx, w({\n      pathname: void 0 === b ? \"/\" : b,\n      search: void 0 === c ? \"\" : c,\n      hash: void 0 === a ? \"\" : a,\n      state: d.usr || null,\n      key: d.key || \"default\"\n    })];\n  }\n\n  function h() {\n    if (n) c.call(n), n = null;else {\n      var a = f(),\n          b = a[0];\n      a = a[1];\n      if (c.length) {\n        if (null != b) {\n          var d = m - b;\n          d && (n = {\n            action: \"POP\",\n            location: a,\n            retry: function () {\n              k(-1 * d);\n            }\n          }, k(d));\n        } else \"production\" !== process.env.NODE_ENV ? x(!1, \"You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.\") : void 0;\n      } else v(\"POP\");\n    }\n  }\n\n  function r(a) {\n    var b = document.querySelector(\"base\"),\n        e = \"\";\n    b && b.getAttribute(\"href\") && (b = g.location.href, e = b.indexOf(\"#\"), e = -1 === e ? b : b.slice(0, e));\n    return e + \"#\" + (\"string\" === typeof a ? a : C(a));\n  }\n\n  function u(a, c) {\n    void 0 === c && (c = null);\n    return w(_extends({}, b, {}, \"string\" === typeof a ? D(a) : a, {\n      state: c,\n      key: A()\n    }));\n  }\n\n  function v(a) {\n    p = a;\n    a = f();\n    m = a[0];\n    b = a[1];\n    d.call({\n      action: p,\n      location: b\n    });\n  }\n\n  function t(a, b) {\n    function d() {\n      t(a, b);\n    }\n\n    var e = u(a, b);\n    \"production\" !== process.env.NODE_ENV ? x(\"/\" === e.pathname.charAt(0), \"Relative pathnames are not supported in hash history.push(\" + JSON.stringify(a) + \")\") : void 0;\n\n    if (!c.length || (c.call({\n      action: \"PUSH\",\n      location: e,\n      retry: d\n    }), !1)) {\n      var f = [{\n        usr: e.state,\n        key: e.key,\n        idx: m + 1\n      }, r(e)];\n      e = f[0];\n      f = f[1];\n\n      try {\n        q.pushState(e, null, f);\n      } catch (F) {\n        g.location.assign(f);\n      }\n\n      v(\"PUSH\");\n    }\n  }\n\n  function l(a, b) {\n    function e() {\n      l(a, b);\n    }\n\n    var d = u(a, b);\n    \"production\" !== process.env.NODE_ENV ? x(\"/\" === d.pathname.charAt(0), \"Relative pathnames are not supported in hash history.replace(\" + JSON.stringify(a) + \")\") : void 0;\n    c.length && (c.call({\n      action: \"REPLACE\",\n      location: d,\n      retry: e\n    }), 1) || (d = [{\n      usr: d.state,\n      key: d.key,\n      idx: m\n    }, r(d)], q.replaceState(d[0], null, d[1]), v(\"REPLACE\"));\n  }\n\n  function k(a) {\n    q.go(a);\n  }\n\n  a = (void 0 === a ? {} : a).window;\n  var g = void 0 === a ? document.defaultView : a,\n      q = g.history,\n      n = null;\n  g.addEventListener(\"popstate\", h);\n  g.addEventListener(\"hashchange\", function () {\n    var a = f()[1];\n    C(a) !== C(b) && h();\n  });\n  var p = \"POP\";\n  a = f();\n  var m = a[0],\n      b = a[1],\n      c = z(),\n      d = z();\n  null == m && (m = 0, q.replaceState(_extends({}, q.state, {\n    idx: m\n  }), null));\n  return {\n    get action() {\n      return p;\n    },\n\n    get location() {\n      return b;\n    },\n\n    createHref: r,\n    push: t,\n    replace: l,\n    go: k,\n    back: function () {\n      k(-1);\n    },\n    forward: function () {\n      k(1);\n    },\n    listen: function (a) {\n      return d.push(a);\n    },\n    block: function (a) {\n      var b = c.push(a);\n      1 === c.length && g.addEventListener(\"beforeunload\", y);\n      return function () {\n        b();\n        c.length || g.removeEventListener(\"beforeunload\", y);\n      };\n    }\n  };\n};\n\nvar createMemoryHistory = function (a) {\n  function f(a, c) {\n    void 0 === c && (c = null);\n    return w(_extends({}, n, {}, \"string\" === typeof a ? D(a) : a, {\n      state: c,\n      key: A()\n    }));\n  }\n\n  function h(a, c, d) {\n    return !p.length || (p.call({\n      action: a,\n      location: c,\n      retry: d\n    }), !1);\n  }\n\n  function r(a, c) {\n    q = a;\n    n = c;\n    m.call({\n      action: q,\n      location: n\n    });\n  }\n\n  function u(a, c) {\n    var b = f(a, c);\n    \"production\" !== process.env.NODE_ENV ? x(\"/\" === n.pathname.charAt(0), \"Relative pathnames are not supported in memory history.push(\" + JSON.stringify(a) + \")\") : void 0;\n    h(\"PUSH\", b, function () {\n      u(a, c);\n    }) && (g += 1, k.splice(g, k.length, b), r(\"PUSH\", b));\n  }\n\n  function v(a, c) {\n    var b = f(a, c);\n    \"production\" !== process.env.NODE_ENV ? x(\"/\" === n.pathname.charAt(0), \"Relative pathnames are not supported in memory history.replace(\" + JSON.stringify(a) + \")\") : void 0;\n    h(\"REPLACE\", b, function () {\n      v(a, c);\n    }) && (k[g] = b, r(\"REPLACE\", b));\n  }\n\n  function t(a) {\n    var b = Math.min(Math.max(g + a, 0), k.length - 1),\n        d = k[b];\n    h(\"POP\", d, function () {\n      t(a);\n    }) && (g = b, r(\"POP\", d));\n  }\n\n  var l = void 0 === a ? {} : a;\n  a = l.initialEntries;\n  l = l.initialIndex;\n  l = void 0 === l ? 0 : l;\n  var k = (void 0 === a ? [\"/\"] : a).map(function (a) {\n    var b = w(_extends({\n      pathname: \"/\",\n      search: \"\",\n      hash: \"\",\n      state: null,\n      key: A()\n    }, \"string\" === typeof a ? D(a) : a));\n    \"production\" !== process.env.NODE_ENV ? x(\"/\" === b.pathname.charAt(0), \"Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: \" + JSON.stringify(a) + \")\") : void 0;\n    return b;\n  }),\n      g = Math.min(Math.max(l, 0), k.length - 1),\n      q = \"POP\",\n      n = k[g],\n      p = z(),\n      m = z();\n  return {\n    get index() {\n      return g;\n    },\n\n    get action() {\n      return q;\n    },\n\n    get location() {\n      return n;\n    },\n\n    createHref: function (a) {\n      return \"string\" === typeof a ? a : C(a);\n    },\n    push: u,\n    replace: v,\n    go: t,\n    back: function () {\n      t(-1);\n    },\n    forward: function () {\n      t(1);\n    },\n    listen: function (a) {\n      return m.push(a);\n    },\n    block: function (a) {\n      return p.push(a);\n    }\n  };\n};\n\nvar createPath = C;\nvar parsePath = D;\nexport { createBrowserHistory, createHashHistory, createMemoryHistory, createPath, parsePath };","map":{"version":3,"mappings":"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","names":["readOnly","Object","NODE_ENV","obj","warning","cond","freeze","a","console","Error","promptBeforeUnload","f","event","createEvents","length","handlers","push","fn","handler","call","createKey","Math","createPath","h","parsePath","path","pieces","hashIndex","searchIndex","createBrowserHistory","getIndexAndLocation","window","g","state","globalHistory","idx","pathname","search","hash","key","createHref","to","C","r","getNextLocation","e","location","u","applyTx","nextAction","action","index","listeners","v","c","retry","B","nextLocation","blockers","usr","historyState","url","error","PushAction","replace","ReplaceAction","d","go","n","document","blockedPopTx","PopStateEventType","nextIndex","PopAction","history","back","forward","listen","block","unblock","BeforeUnloadEventType","createHashHistory","b","handlePop","k","base","href","JSON","HashChangeEventType","createMemoryHistory","allowTx","entries","lowerBound","l","initialIndex","initialEntries","entry"],"sources":["../../packages/history/modules/index.js"],"sourcesContent":["const PopAction = 'POP';\nconst PushAction = 'PUSH';\nconst ReplaceAction = 'REPLACE';\n\nconst BeforeUnloadEventType = 'beforeunload';\nconst HashChangeEventType = 'hashchange';\nconst PopStateEventType = 'popstate';\n\nconst readOnly = __DEV__ ? obj => Object.freeze(obj) : obj => obj;\n\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== 'undefined') console.warn(message);\n\n    try {\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// BROWSER\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Browser history stores the location in regular URLs. This is the\n * standard for most web apps, but it requires some configuration on\n * the server to ensure you serve the same app at multiple URLs.\n */\nexport function createBrowserHistory({ window = document.defaultView } = {}) {\n  let globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    let { pathname, search, hash } = window.location;\n    let state = globalHistory.state || {};\n    return [\n      state.idx,\n      readOnly({\n        pathname,\n        search,\n        hash,\n        state: state.usr || null,\n        key: state.key || 'default'\n      })\n    ];\n  }\n\n  let blockedPopTx = null;\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      let nextAction = PopAction;\n      let [nextIndex, nextLocation] = getIndexAndLocation();\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          let n = index - nextIndex;\n          if (n) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry() {\n                go(n * -1);\n              }\n            };\n\n            go(n);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          warning(\n            false,\n            // TODO: Write up a doc that explains our blocking strategy in\n            // detail and link to it here so people can understand better\n            // what is going on and how to avoid it.\n            `You are trying to block a POP navigation to a location that was not ` +\n              `created by the history library. The block will fail silently in ` +\n              `production, but in general you should do all navigation with the ` +\n              `history library (instead of using window.history.pushState directly) ` +\n              `to avoid this situation.`\n          );\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop);\n\n  let action = PopAction;\n  let [index, location] = getIndexAndLocation();\n  let blockers = createEvents();\n  let listeners = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState({ ...globalHistory.state, idx: index }, null);\n  }\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  }\n\n  function getNextLocation(to, state = null) {\n    return readOnly({\n      ...location,\n      ...(typeof to === 'string' ? parsePath(to) : to),\n      state,\n      key: createKey()\n    });\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [\n      {\n        usr: nextLocation.state,\n        key: nextLocation.key,\n        idx: index\n      },\n      createHref(nextLocation)\n    ];\n  }\n\n  function allowTx(action, location, retry) {\n    return (\n      !blockers.length || (blockers.call({ action, location, retry }), false)\n    );\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n    [index, location] = getIndexAndLocation();\n    listeners.call({ action, location });\n  }\n\n  function push(to, state) {\n    let nextAction = PushAction;\n    let nextLocation = getNextLocation(to, state);\n    function retry() {\n      push(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      let [historyState, url] = getHistoryStateAndUrl(nextLocation, index + 1);\n\n      // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n      try {\n        globalHistory.pushState(historyState, null, url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    let nextAction = ReplaceAction;\n    let nextLocation = getNextLocation(to, state);\n    function retry() {\n      replace(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      let [historyState, url] = getHistoryStateAndUrl(nextLocation, index);\n\n      // TODO: Support forced reloading\n      globalHistory.replaceState(historyState, null, url);\n\n      applyTx(nextAction);\n    }\n  }\n\n  function go(n) {\n    globalHistory.go(n);\n  }\n\n  let history = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return location;\n    },\n    createHref,\n    push,\n    replace,\n    go,\n    back() {\n      go(-1);\n    },\n    forward() {\n      go(1);\n    },\n    listen(fn) {\n      return listeners.push(fn);\n    },\n    block(fn) {\n      let unblock = blockers.push(fn);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function() {\n        unblock();\n\n        // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n\n  return history;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// HASH\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Hash history stores the location in window.location.hash. This makes\n * it ideal for situations where you don't want to send the location to\n * the server for some reason, either because you do cannot configure it\n * or the URL space is reserved for something else.\n */\nexport function createHashHistory({ window = document.defaultView } = {}) {\n  let globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    let { pathname = '/', search = '', hash = '' } = parsePath(\n      window.location.hash.substr(1)\n    );\n    let state = globalHistory.state || {};\n    return [\n      state.idx,\n      readOnly({\n        pathname,\n        search,\n        hash,\n        state: state.usr || null,\n        key: state.key || 'default'\n      })\n    ];\n  }\n\n  let blockedPopTx = null;\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      let nextAction = PopAction;\n      let [nextIndex, nextLocation] = getIndexAndLocation();\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          let n = index - nextIndex;\n          if (n) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry() {\n                go(n * -1);\n              }\n            };\n\n            go(n);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          warning(\n            false,\n            // TODO: Write up a doc that explains our blocking strategy in\n            // detail and link to it here so people can understand better\n            // what is going on and how to avoid it.\n            `You are trying to block a POP navigation to a location that was not ` +\n              `created by the history library. The block will fail silently in ` +\n              `production, but in general you should do all navigation with the ` +\n              `history library (instead of using window.history.pushState directly) ` +\n              `to avoid this situation.`\n          );\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop);\n\n  // TODO: Is this still necessary? Which browsers do\n  // not trigger popstate when the hash changes?\n  window.addEventListener(HashChangeEventType, event => {\n    let [, nextLocation] = getIndexAndLocation();\n\n    // Ignore extraneous hashchange events.\n    if (createPath(nextLocation) !== createPath(location)) {\n      handlePop();\n    }\n  });\n\n  let action = PopAction;\n  let [index, location] = getIndexAndLocation();\n  let blockers = createEvents();\n  let listeners = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState({ ...globalHistory.state, idx: index }, null);\n  }\n\n  function getBaseHref() {\n    let base = document.querySelector('base');\n    let href = '';\n\n    if (base && base.getAttribute('href')) {\n      let url = window.location.href;\n      let hashIndex = url.indexOf('#');\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n\n    return href;\n  }\n\n  function createHref(to) {\n    return getBaseHref() + '#' + (typeof to === 'string' ? to : createPath(to));\n  }\n\n  function getNextLocation(to, state = null) {\n    return readOnly({\n      ...location,\n      ...(typeof to === 'string' ? parsePath(to) : to),\n      state,\n      key: createKey()\n    });\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [\n      {\n        usr: nextLocation.state,\n        key: nextLocation.key,\n        idx: index\n      },\n      createHref(nextLocation)\n    ];\n  }\n\n  function allowTx(action, location, retry) {\n    return (\n      !blockers.length || (blockers.call({ action, location, retry }), false)\n    );\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n    [index, location] = getIndexAndLocation();\n    listeners.call({ action, location });\n  }\n\n  function push(to, state) {\n    let nextAction = PushAction;\n    let nextLocation = getNextLocation(to, state);\n    function retry() {\n      push(to, state);\n    }\n\n    warning(\n      nextLocation.pathname.charAt(0) === '/',\n      `Relative pathnames are not supported in hash history.push(${JSON.stringify(\n        to\n      )})`\n    );\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      let [historyState, url] = getHistoryStateAndUrl(nextLocation, index + 1);\n\n      // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n      try {\n        globalHistory.pushState(historyState, null, url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    let nextAction = ReplaceAction;\n    let nextLocation = getNextLocation(to, state);\n    function retry() {\n      replace(to, state);\n    }\n\n    warning(\n      nextLocation.pathname.charAt(0) === '/',\n      `Relative pathnames are not supported in hash history.replace(${JSON.stringify(\n        to\n      )})`\n    );\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      let [historyState, url] = getHistoryStateAndUrl(nextLocation, index);\n\n      // TODO: Support forced reloading\n      globalHistory.replaceState(historyState, null, url);\n\n      applyTx(nextAction);\n    }\n  }\n\n  function go(n) {\n    globalHistory.go(n);\n  }\n\n  let history = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return location;\n    },\n    createHref,\n    push,\n    replace,\n    go,\n    back() {\n      go(-1);\n    },\n    forward() {\n      go(1);\n    },\n    listen(fn) {\n      return listeners.push(fn);\n    },\n    block(fn) {\n      let unblock = blockers.push(fn);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function() {\n        unblock();\n\n        // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n\n  return history;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// MEMORY\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Memory history stores the current location in memory. It is designed\n * for use in stateful non-browser environments like headless tests (in\n * node.js) and React Native.\n */\nexport function createMemoryHistory({\n  initialEntries = ['/'],\n  initialIndex = 0\n} = {}) {\n  let entries = initialEntries.map(entry => {\n    let location = readOnly({\n      pathname: '/',\n      search: '',\n      hash: '',\n      state: null,\n      key: createKey(),\n      ...(typeof entry === 'string' ? parsePath(entry) : entry)\n    });\n\n    warning(\n      location.pathname.charAt(0) === '/',\n      `Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: ${JSON.stringify(\n        entry\n      )})`\n    );\n\n    return location;\n  });\n  let index = clamp(initialIndex, 0, entries.length - 1);\n\n  let action = PopAction;\n  let location = entries[index];\n  let blockers = createEvents();\n  let listeners = createEvents();\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  }\n\n  function getNextLocation(to, state = null) {\n    return readOnly({\n      ...location,\n      ...(typeof to === 'string' ? parsePath(to) : to),\n      state,\n      key: createKey()\n    });\n  }\n\n  function allowTx(action, location, retry) {\n    return (\n      !blockers.length || (blockers.call({ action, location, retry }), false)\n    );\n  }\n\n  function applyTx(nextAction, nextLocation) {\n    action = nextAction;\n    location = nextLocation;\n    listeners.call({ action, location });\n  }\n\n  function push(to, state) {\n    let nextAction = PushAction;\n    let nextLocation = getNextLocation(to, state);\n    function retry() {\n      push(to, state);\n    }\n\n    warning(\n      location.pathname.charAt(0) === '/',\n      `Relative pathnames are not supported in memory history.push(${JSON.stringify(\n        to\n      )})`\n    );\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function replace(to, state) {\n    let nextAction = ReplaceAction;\n    let nextLocation = getNextLocation(to, state);\n    function retry() {\n      replace(to, state);\n    }\n\n    warning(\n      location.pathname.charAt(0) === '/',\n      `Relative pathnames are not supported in memory history.replace(${JSON.stringify(\n        to\n      )})`\n    );\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      entries[index] = nextLocation;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function go(n) {\n    let nextIndex = clamp(index + n, 0, entries.length - 1);\n    let nextAction = PopAction;\n    let nextLocation = entries[nextIndex];\n    function retry() {\n      go(n);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index = nextIndex;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  let history = {\n    get index() {\n      return index;\n    },\n    get action() {\n      return action;\n    },\n    get location() {\n      return location;\n    },\n    createHref,\n    push,\n    replace,\n    go,\n    back() {\n      go(-1);\n    },\n    forward() {\n      go(1);\n    },\n    listen(fn) {\n      return listeners.push(fn);\n    },\n    block(fn) {\n      return blockers.push(fn);\n    }\n  };\n\n  return history;\n}\n\nfunction clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// UTILS\n////////////////////////////////////////////////////////////////////////////////\n\nfunction promptBeforeUnload(event) {\n  // Cancel the event.\n  event.preventDefault();\n  // Chrome (and legacy IE) requires returnValue to be set.\n  event.returnValue = '';\n}\n\nfunction createEvents() {\n  let handlers = [];\n\n  return {\n    get length() {\n      return handlers.length;\n    },\n    push(fn) {\n      handlers.push(fn);\n      return function() {\n        handlers = handlers.filter(handler => handler !== fn);\n      };\n    },\n    call(arg) {\n      handlers.forEach(fn => fn && fn(arg));\n    }\n  };\n}\n\nfunction createKey() {\n  return Math.random()\n    .toString(36)\n    .substr(2, 8);\n}\n\nexport function createPath({ pathname = '/', search = '', hash = '' }) {\n  return pathname + search + hash;\n}\n\nexport function parsePath(path) {\n  let pieces = {};\n\n  if (path) {\n    let hashIndex = path.indexOf('#');\n    if (hashIndex >= 0) {\n      pieces.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n\n    let searchIndex = path.indexOf('?');\n    if (searchIndex >= 0) {\n      pieces.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n\n    if (path) {\n      pieces.pathname = path;\n    }\n  }\n\n  return pieces;\n}\n"]},"metadata":{},"sourceType":"module"}